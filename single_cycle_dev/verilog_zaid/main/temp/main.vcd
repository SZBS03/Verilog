$date
	Tue Dec  3 02:16:13 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module MAIN_tb $end
$var reg 1 ! RW $end
$var reg 1 " clk $end
$var reg 32 # dataIN [31:0] $end
$var reg 1 $ en $end
$var reg 1 % rst $end
$scope module u_MAIN $end
$var wire 1 ! RW $end
$var wire 1 " clk $end
$var wire 32 & dataIN [31:0] $end
$var wire 1 $ en $end
$var wire 1 % rst $end
$var wire 32 ' write_data [31:0] $end
$var wire 5 ( rs2 [4:0] $end
$var wire 5 ) rs1 [4:0] $end
$var wire 1 * regWrite $end
$var wire 32 + read_data2 [31:0] $end
$var wire 32 , read_data1 [31:0] $end
$var wire 5 - rd [4:0] $end
$var wire 1 . operandB $end
$var wire 1 / operandA $end
$var wire 1 0 memWrite $end
$var wire 1 1 memToReg $end
$var wire 32 2 load_write [31:0] $end
$var wire 32 3 instMemOUT [31:0] $end
$var wire 32 4 imm_gen_inst [31:0] $end
$var wire 32 5 dataMemOUT [31:0] $end
$var wire 5 6 counter_address [4:0] $end
$var wire 32 7 aluOut [31:0] $end
$var wire 6 8 aluOP [5:0] $end
$var wire 32 9 PC [31:0] $end
$var wire 32 : OpB [31:0] $end
$var wire 32 ; OpA [31:0] $end
$scope module o_register $end
$var wire 1 " clk $end
$var wire 1 % reset $end
$var wire 32 < write_data [31:0] $end
$var wire 5 = rs2_data [4:0] $end
$var wire 5 > rs1_data [4:0] $end
$var wire 1 * regWrite $end
$var wire 5 ? rd_data [4:0] $end
$var reg 32 @ read_data1 [31:0] $end
$var reg 32 A read_data2 [31:0] $end
$var integer 32 B i [31:0] $end
$upscope $end
$scope module u_ControlDecode $end
$var wire 5 C rs2 [4:0] $end
$var wire 5 D rs1 [4:0] $end
$var wire 5 E rd [4:0] $end
$var wire 7 F opcode [6:0] $end
$var wire 32 G instruction [31:0] $end
$var wire 7 H func7 [6:0] $end
$var wire 3 I func3 [2:0] $end
$var reg 6 J aluOP [5:0] $end
$var reg 1 K branch $end
$var reg 32 L imm_gen_inst [31:0] $end
$var reg 1 M jalEN $end
$var reg 1 N jalrEN $end
$var reg 1 1 memToReg $end
$var reg 1 0 memWrite $end
$var reg 1 / operandA $end
$var reg 1 . operandB $end
$var reg 1 * regWrite $end
$upscope $end
$scope module u_DMI $end
$var wire 32 O LW [31:0] $end
$var wire 6 P aluOP [5:0] $end
$var wire 32 Q load [31:0] $end
$var wire 16 R LHU [15:0] $end
$var wire 16 S LH [15:0] $end
$var wire 8 T LBU [7:0] $end
$var wire 8 U LB [7:0] $end
$var reg 32 V load_data [31:0] $end
$upscope $end
$scope module u_RAM2 $end
$var wire 5 W address [4:0] $end
$var wire 1 " clk $end
$var wire 32 X dataIN [31:0] $end
$var wire 1 0 readWrite $end
$var reg 32 Y dataOUT [31:0] $end
$upscope $end
$scope module u_alu $end
$var wire 32 Z a [31:0] $end
$var wire 32 [ b [31:0] $end
$var wire 6 \ opcode [5:0] $end
$var reg 32 ] c [31:0] $end
$upscope $end
$scope module u_fetch $end
$var wire 1 " clk $end
$var wire 1 $ en $end
$var wire 1 % rst $end
$var reg 32 ^ PC [31:0] $end
$var reg 32 _ counterOUT [31:0] $end
$var reg 32 ` instruction [31:0] $end
$var reg 5 a mem_address [4:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b11111 a
bx `
b11111111111111111111111111111111 _
b11111111111111111111111111111111 ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
xN
xM
bx L
xK
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
b11111111111111111111111111111111 9
bx 8
bx 7
b11111 6
bx 5
bx 4
bx 3
bx 2
x1
x0
x/
x.
bx -
bx ,
bx +
x*
bx )
bx (
bx '
bx &
0%
0$
bx #
1"
x!
$end
#5
0"
#10
b100 ;
b100 Z
b0 ,
b0 @
0M
0N
b101 8
b101 J
b101 P
b101 \
0K
0.
1/
00
01
1*
b100 (
b100 =
b100 C
b0 )
b0 >
b0 D
b1 -
b1 ?
b1 E
b0 H
b0 I
b10011 F
b100 4
b100 L
b10000000000000010010011 3
b10000000000000010010011 G
b10000000000000010010011 `
b0 6
b0 a
b11 9
b11 _
b11 ^
1"
1$
#15
0"
#20
b101 ;
b101 Z
b101 (
b101 =
b101 C
b10 -
b10 ?
b10 E
b101 4
b101 L
b10100000000000100010011 3
b10100000000000100010011 G
b10100000000000100010011 `
b1 6
b1 a
b111 9
b111 _
b111 ^
1"
#25
0"
#30
bx ,
bx @
b10011 8
b10011 J
b10011 P
b10011 \
0/
1*
bx ;
bx Z
b1 (
b1 =
b1 C
b10 )
b10 >
b10 D
b100 -
b100 ?
b100 E
b100000 H
b110011 F
b0 4
b0 L
b1000000000100010000001000110011 3
b1000000000100010000001000110011 G
b1000000000100010000001000110011 `
b10 6
b10 a
b1011 9
b1011 _
b1011 ^
1"
#35
0"
#40
b0 '
b0 <
b0 W
b0 7
b0 ]
b0 8
b0 J
b0 P
b0 \
0*
bx (
bx =
bx C
bx )
bx >
bx D
bx -
bx ?
bx E
bx H
bx I
bx F
bx 3
bx G
bx `
b11 6
b11 a
b1111 9
b1111 _
b1111 ^
1"
#45
0"
#50
b100 6
b100 a
b10011 9
b10011 _
b10011 ^
1"
#55
0"
#60
b0 :
b0 [
b0 +
b0 A
b0 X
b100 '
b100 <
b1 W
b100 ;
b100 Z
b100 7
b100 ]
b0 ,
b0 @
1/
1*
b101 8
b101 J
b101 P
b101 \
b100 4
b100 L
b100 (
b100 =
b100 C
b0 )
b0 >
b0 D
b1 -
b1 ?
b1 E
b0 H
b0 I
b10011 F
b100000 B
b10000000000000010010011 3
b10000000000000010010011 G
b10000000000000010010011 `
b0 6
b0 a
b0 9
b0 _
b0 ^
1"
1%
#65
0"
#70
b101 '
b101 <
b101 7
b101 ]
b101 ;
b101 Z
b101 (
b101 =
b101 C
b10 -
b10 ?
b10 E
b101 4
b101 L
b10100000000000100010011 3
b10100000000000100010011 G
b10100000000000100010011 `
b1 6
b1 a
b100 9
b100 _
b100 ^
1"
0%
#75
0"
#80
b101 ,
b101 @
b1 '
b1 <
b0 W
b100 :
b100 [
b1 7
b1 ]
b100 +
b100 A
b100 X
b10011 8
b10011 J
b10011 P
b10011 \
0/
1*
b101 ;
b101 Z
b1 (
b1 =
b1 C
b10 )
b10 >
b10 D
b100 -
b100 ?
b100 E
b100000 H
b110011 F
b0 4
b0 L
b1000000000100010000001000110011 3
b1000000000100010000001000110011 G
b1000000000100010000001000110011 `
b10 6
b10 a
b1000 9
b1000 _
b1000 ^
1"
#85
0"
#90
b0 '
b0 <
bx :
bx [
bx ;
bx Z
b0 7
b0 ]
bx +
bx A
bx X
bx ,
bx @
b0 8
b0 J
b0 P
b0 \
0*
bx (
bx =
bx C
bx )
bx >
bx D
bx -
bx ?
bx E
bx H
bx I
bx F
bx 3
bx G
bx `
b11 6
b11 a
b1100 9
b1100 _
b1100 ^
1"
#95
0"
#100
b11111 6
b11111 a
b11111111111111111111111111111111 9
b11111111111111111111111111111111 _
b11111111111111111111111111111111 ^
1"
0$
#105
0"
#110
1"
#115
0"
#120
1"
#125
0"
#130
1"
#135
0"
#140
1"
#145
0"
#150
1"
#155
0"
#160
1"
#165
0"
#170
1"
#175
0"
#180
1"
#185
0"
#190
1"
#195
0"
#200
1"
